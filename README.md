## 并发编程
1. 使用多线程的理由之一是与进程相比，使用线程是一种非常节俭的的多任务操作方式，启动一个进程需要给它分配独立的地址空间，建立众多的表来维护代码段、堆栈段和数据段。而运行一个进程中的多个线程，彼此之间使用相同的地址空间，共享大部分数据，启动一个线程的时间要远小于启动一个进程所花费的时间。并且，线程间切换开销要远小于进程间切换开销。进程间切换的开销大概是线程间切换的30倍。
2. 使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。 

除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点： 
+ 提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。 
+ 使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。 
+ 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。 



## 原子变量
### 内存序
#### 定义
内存序规定了多线程中内存访问的顺序性和可见性。
在无锁编程中，我们要解决的两个核心问题:
1. 原子性，操作不会被其他线程中断
2. 顺序性，操作的执行顺序和可见性保证

#### 类型
1. std::memory_order_relaxed
- 只保证原子性，不保证顺序性
2. std::memory_order_acquire
- 保证顺序性，该操作之后的所有读写操作不会被重排到该操作之前
- 用于读取数据
3. std::memory_order_release
- 保证顺序，该操作之前的所有读写操作不会被重排到该操作之后
- 用于写入数据

## 保证RingBuffer的线程安全的方法
1. 锁
2. 原子操作CAS
3. 无锁数据结构

### 原子操作
#### ABA问题
原子操作会出现ABA问题：
在多线程环境中，一个线程读取了一个值A，然后另一个线程将这个值改为B，再改回A，
第一个线程在读取时并不知道这个值已经被修改过了，导致数据不一致的问题。

解决方法：
1. 引入版本号：每次修改数据时，版本号也会随之增加。
2. 在读取数据时，检查版本号是否与之前读取时的版本号一致，如果不一致则认为数据已经被修改过了。

#### 版本计数器
1. 每个数据元素都有一个版本号
2. 写操作时，先读取当前版本号，修改数据后再更新版本号
3. 读操作时，读取数据和版本号，如果版本号与之前读取的版本号一致，则认为数据没有被修改过
4. 如果版本号不一致，则认为数据已经被修改过，需要重新读取数

### 无锁编程
1. 尾指针只由写线程修改
2. 头指针只由读线程修改
3. 采用特定操作顺序，写操作先更新数据元素再移动；读操作先读取数据元素再移动头指针

该RingBuffer实际上不是lock-free，而是lockless的数据结构，lock-free的定义为:
```
A sturcture is lock-free if only any thread can be indefinitely suspended at any point
while still leaving the structure usable by the remaining threads.
```

## 应用场景
1. 传感器数据
2. 视频数据
3. 音频数据
4. 网络通信
