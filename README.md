## 原子变量
### 内存序
#### 定义
内存序规定了多线程中内存访问的顺序性和可见性。
在无锁编程中，我们要解决的两个核心问题:
1. 原子性，操作不会被其他线程中断
2. 顺序性，操作的执行顺序和可见性保证

#### 类型
1. std::memory_order_relaxed
- 只保证原子性，不保证顺序性
2. std::memory_order_acquire
- 保证顺序性，该操作之后的所有读写操作不会被重排到该操作之前
- 用于读取数据
3. std::memory_order_release
- 保证顺序，该操作之前的所有读写操作不会被重排到该操作之后
- 用于写入数据

## 保证RingBuffer的线程安全的方法
1. 锁
2. 原子操作CAS
3. 无锁数据结构

### 原子操作
#### ABA问题
原子操作会出现ABA问题：
在多线程环境中，一个线程读取了一个值A，然后另一个线程将这个值改为B，再改回A，
第一个线程在读取时并不知道这个值已经被修改过了，导致数据不一致的问题。

解决方法：
1. 引入版本号：每次修改数据时，版本号也会随之增加。
2. 在读取数据时，检查版本号是否与之前读取时的版本号一致，如果不一致则认为数据已经被修改过了。

#### 版本计数器
1. 每个数据元素都有一个版本号
2. 写操作时，先读取当前版本号，修改数据后再更新版本号
3. 读操作时，读取数据和版本号，如果版本号与之前读取的版本号一致，则认为数据没有被修改过
4. 如果版本号不一致，则认为数据已经被修改过，需要重新读取数

### 无锁编程
1. 尾指针只由写线程修改
2. 头指针只由读线程修改
3. 采用特定操作顺序，写操作先更新数据元素再移动；读操作先读取数据元素再移动头指针

该RingBuffer实际上不是lock-free，而是lockless的数据结构，lock-free的定义为:
```
A sturcture is lock-free if only any thread can be indefinitely suspended at any point
while still leaving the structure usable by the remaining threads.
```

## 应用场景
1. 传感器数据
2. 视频数据
3. 音频数据
4. 网络通信